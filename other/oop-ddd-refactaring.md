## はじめに
新人研修が終わり「オブジェクト思考でなぜつくるのか」「ドメイン駆動設計入門」という2つの本を読みました。
そこで自分が今までは、ただ動くものを作っていただけなのだと感じ、OOPとDDDの設計を理解した綺麗なコードを書きたいと思いました。
今回は勉強用として開発を進めていた認証機能をOOPとDDDの設計に沿ったコードにリファクタリングを行っていきたいと思います！

## 想定読者
想定読者は以下のような方々です。
```
初学者でただ動くものを作っていけど、直感的で綺麗なコードを書きたい方
OOPやDDDに興味がありをなんとなくではなく意識して開発を進めたい方
```
初学者や未経験で頑張っている方に読んでいただいて、興味を持っていただければと思っております。

## 結論(感想)
※現段階で思っていること<br>
結論(感想)を最初に言ってしまうと、「何が正解かわからない。。。意識することが多い。。。」でした。
OOPとDDDの両方を意識しての開発を初めて進めてみたのですが、最適解がわからない階層構造って、、、という状態
ユビキタス言語やロバネスク分析などを行うには情報が少なすぎた。等色々な壁があり実際にリファクタリングを行うまでにかなり時間を取られてしまいました。
ドメインモデルを決めるのに2日ぐらい考えたがピンとくるのがなかった。まだまだ理解できていない。結局今どれだけ考えても結論が出ないので、今自分が考えつくドメインモデルを設計し、リファクタリングを重ねてどんどん改善していこうとい結論に至りました。

## OOP
オブジェクト指向プログラミング: OOP(Object Oriented Programming)

## DDD
>ドメイン駆動設計とはなにか？
では、ドメイン駆動設計の基礎知識ということで「ドメイン駆動設計とはなにか？」という話です。まず、ものすごく単純な話、ドメイン駆動設計はソフトウェア設計の考え方とやり方の1つなんですね。世の中には、いろんな設計のスタイルや考え方の方法論があって、ドメイン駆動設計は、そういう設計スタイルの1つです。

## アプリ
簡単な認証機能を行うだけのアプリ
認証機能を開発しようと思ったきっかけとして、プログラミングで初めて勉強した言語がRubyでフレームワークがRailsでした、認証機能は`gem devise`を入れれば良くも悪くも簡単に実装出来てしまいます。
このため当初ScalaとPlayFrameworkを使ってアプリ開発を始めた時は同様に認証機能を実装できるgemのようなモノがあると思っていました。当然実装出来ませんでした。
そのリベンジとして新人研修終わりに開発を始めました！

## ソースコード

https://github.com/takapi327/scala-play-app/tree/develop

## 利用した技術
### API側言語
Scala
### API側フレームワーク
PlayFramwork
### アプリ側
Angular
### DB
MySQL
## ユビキタス言語
#### ユビキタス言語とは何か？
>ユーザーが使っている言葉でプログラムを検索すれば、該当する概念の挙動を表しているクラスに行き着くようになってないといけませんし、そうなっている状態が保守しやすいプログラムであると言えます。ユーザーの言葉からプログラムの言葉に翻訳しないといけなかったり、一つの概念が複数のファイルに分割されている状況は可能な限り避けないといけません。

|ユビキタス言語|英語名|概要|
|-|-|-|
|ユーザー|User|ログイン、サインインを行うユーザー|
|認証情報|UserAuthenticate|ユーザーの保有する認証関係の情報|

<img width="437" alt="スクリーンショット 2020-08-03 1 33 08" src="https://user-images.githubusercontent.com/57429437/89127564-4c60a900-d529-11ea-8ba8-96faed59d2b2.png">

## 設計
- ドメインモデル
- DB設計
- ユースケースモデリング
- 画面設計(画面遷移図)
- 画面設計(ワイヤーフレーム)
- ロバストネス分析
- クラス図
- データモデリング(ER図)
- UI設計
- 実装
### ドメインモデル
今回はEntityの識別子のみValueObjectにするようにしました。

本やサイトを見ると、誤った代入を防ぐためにも全てのプロパティにそれぞれValueObjectを定義しているようでしたが、今回はそうしませんでした。

というのも、「ドメイン駆動設計入門」の著者もValueObjectにする判断基準として、下記のように記していました。
>ドメインモデルとして挙げられていなかった概念をValueObjectにすべきかどうかは、「そこにルールが存在しているか」「それ単体で取り扱いたいか」という点を重要視しています。

なので今回はこの判断基準に則って実装を行っていき、他のプロパティは標準のStringにするようにしました。

#### Entity
- User
```
case class User(
  userId:   Option[UserId],
  nameInfo: UserName,
  email:    String
){
  val mailPattern = 
	"""[a-zA-Z0-9\.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*""".r
  require(
    mailPattern.matches(mail),
    mail
  )
}
```
- UserPassword
```
case class UserPassword (
  userId:  Option[UserId],
  hash:    String
)
```
```
def hash(password: String): String = PBKDF2.hash(password)
def verify(password: String, hash: String): Boolean = PBKDF2.compare(password, hash)
```

- AuthToken
```
case class AuthToken(
  id:     Option[Id],
  userId: User.Id,
)
```
#### ValueObject
- UserId
```
case class UserId (id: Long)
```
- UserName
```
case class UserName (
  firstName: String,
  lastName:  String
) {
  lazy val fullName =
	s"${firstName} ${lastName}"
}
```

#### Service

< 図 >

### DB設計
リファクタリングをする前はUserに関するテーブルを3つに分けていたのですが、Userのパスワードを保存しているテーブルとTokenを保存しているテーブルを一意に認証用のテーブルとしてまとめました。
なので今回は、Userに関するテーブルを2つに分けて実装を行いました。
理由としてはテーブル間のデータ比較などを練習するため、認証する度にUserの詳細な情報が入っているテーブルを触りたくなく、認証で頻繁に扱うデータをまとめたかったためです。
DB設計に関しては、同期におすすめしていただいている「SQLのアンチパターン」という書籍を読んでから設計を行っていきたいと考えています！(順番としては逆な気もしますが...)
#### UserTable
|カラム名|型|制約|
|-|-|-|
|user_id|BIGINT(20)|unsigned NOT NULL AUTO_INCREMENT PRIMARY KEY|
|full_name|VARCHAR(255)||
|mail|VARCHAR(255)|CHARSET ascii  NOT NULL UNIQUE KEY|
#### Table
|カラム名|型|制約|
|-|-|-|
|user_id|BIGINT(20)|PRIMARY KEY|
|nick_name|VARCHAR(255)||
|password|VARCHAR(255)|CHARSET ascii  NOT NULL|
 #### UserAuthenticateTable
|カラム名|型|制約|
|-|-|-|
|user_id|BIGINT(20)|PRIMARY KEY|
|token|VARCHAR(255)|CHARSET ascii UNIQUE KEY|

### ユースケースモデリング
>ユースケースモデリングとは？
ユーザーがシステムで何をするのか？何をできるのか？何をできないのか？といったことを明確化するためのもの。

個人的にこれを作成してから実装に入ることで、どういう処理が必要なのかどこで例外が発生して発生した例外をどのようにして対処するのかが明確になり、スムーズに開発を進めることができました。
またテストを行うときも簡易なテスト仕様書のようになっているためやりやすいと感じました。

|タイトル|内容|
|-|-|
|ユースケース名|ログイン|
|目的|ログインすること|
|アクター|ユーザー|
|画面推移|ログイン画面 -> トップページ|
|前提条件|未ログイン状態であること|
|メインフロー|1.ユーザーはユーザー名とパスワードを入力する<br>2. システムはユーザー名とパスワードを入力されたことを確認したら「ログイン」ボタンをdisable状態からenable状態にする<br>3.ユーザーは「ログイン」ボタンを押す<br>4.システムはユーザー名に該当するユーザー情報を取得する<br>5.システムは入力されたパスワードが取得したユーザーのものと一致するか比較する<br>6.システムはTokenを生成し、レスポンスにCookieと混ぜて返す(認証する)<br>7.システムは画面を「ログイン画面」から「トップページ」に遷移させる|
|例外処理|ユーザー名に該当するユーザーが存在しない場合<br>1.「ログインに失敗しました」というエラーメッセージを表示する<br>2.メインフローの1に戻る<br>パスワードが一致しなかった場合<br>1.「ログインに失敗しました」というエラーメッセージを表示する<br>2.メインフローの1に戻る|

|タイトル|内容|
|-|-|
|ユースケース名| 会員登録|
|目的|会員登録すること|
|アクター|ユーザー|
|画面推移|会員登録画面 -> トップページ|
|前提条件|未ログイン状態であること|
|メインフロー|1.ユーザーはユーザー名とパスワードを入力する<br>2. システムはユーザー名とパスワードを入力されたことを確認したら「会員登録」ボタンをdisable状態からenable状態にする<br>3.ユーザーは「会員登録」ボタンを押す<br>4.システムはユーザー名とパスワードの形式をチェックする<br>5.システムはユーザー名が登録済みのものでないかをチェックする<br>6.システムはパスワードをハッシュ化する<br>7.システムはユーザー名とハッシュ化されたパスワードを登録する<br>8. システムはTokenを生成し、レスポンスにCookieと混ぜて返す(認証する)<br>9.システムは画面を「会員登録画面」から「トップページ」に遷移させる|
|例外処理|ユーザー名が登録済みであった場合<br>1.「このユーザー名は既に登録済みです」というエラーメッセージを表示する<br>2.メインフローの1に戻る<br>パスワードの形式が間違っていた場合<br>1.「パスワードの形式が間違っています」というエラーメッセージを表示する<br>2.メインフローの1に戻る|

|タイトル|内容|
|-|-|
|ユースケース名|ログアウト|
|目的|ログアウトすること|
|アクター|ユーザー|
|画面推移|ログアウト画面 -> トップページ|
|前提条件|ログイン状態であること|
|メインフロー|1.ユーザーは「ログアウト」ボタンを押す<br>2. システムは認証用のTokenを削除<br>3.システムは画面を「ログアウト画面」から「トップページ」に遷移させる|
|例外処理||

### 画面設計(画面遷移図)
認証を通過している場合

|アクセス先|表示される画面|
|-|-|
|詳細画面|詳細画面|
|ログイン画面|トップページ画面|
|サインアップ画面|トップページ画面|

認証を通過していない場合

|アクセス先|表示される画面|
|-|-|
|詳細画面|ログイン画面|
|ログイン画面|トップページ画面|
|サインアップ画面|トップページ画面|

### 画面設計(ワイヤーフレーム)
### ロバストネス分析
※要修正

![Copy of Untitled Diagram-Page-2](https://user-images.githubusercontent.com/57429437/89135579-7f2a9180-d569-11ea-8d7b-651d833ee505.png)

### クラス図
### データモデリング(ER図)
### UI設計
### 実装
### 認証用のActionBuilder
※現状
https://github.com/takapi327/scala-play-app/blob/feature/2020-07-SPA-013-Refactaring-OOP-ActionBuilder/app/action/Auth.scala#L23

### まとめ
## 参考文献
[ボトムアップドメイン駆動設計](https://nrslib.com/bottomup-ddd/)
[ボトムアップドメイン駆動設計 後編](https://nrslib.com/bottomup-ddd-2/)
[3つのキーワードで学ぶ、ドメイン駆動設計の基礎知識](https://logmi.jp/tech/articles/310424)
[ドメイン駆動設計に15年取り組んでわかったこと
「ビジネスルール・値オブジェクト・型」が3つのキーワード](https://logmi.jp/tech/articles/322952)
[ドメイン駆動設計入門](https://www.slideshare.net/TakuyaKitamura1/ddd-29003356)
[ユビキタス言語についての知見を共有します](https://qiita.com/kmdsbng/items/bf415afbeec239a7fd63)
[DDD基礎解説：Entity、ValueObjectってなんなんだ](https://little-hands.hatenablog.com/entry/2018/12/09/entity-value-object)
[ロバストネス図を活用したシステム設計](https://thinkit.co.jp/article/13487)
[データベーステーブル設計の基礎の基礎〜エンティティの抽出・定義から正規化まで](https://employment.en-japan.com/engineerhub/entry/2018/06/22/110000)
[Scalaでイミュータブルなエンティティを実装する](https://dnskimox.hateblo.jp/entry/2019/12/13/212742)
[memcachedの使い方](http://4geek.net/how-to-use-memcached/)
### IxirS
https://medium.com/nextbeat-engineering/%E8%87%AA%E7%A4%BEoss-ixias-%E3%81%AE%E7%B4%B9%E4%BB%8B-ixais-model%E3%83%91%E3%83%83%E3%82%B1%E3%83%BC%E3%82%B8%E3%81%AE%E3%82%B5%E3%83%B3%E3%83%97%E3%83%AB%E3%82%B3%E3%83%BC%E3%83%89-d6e0e5d8e8aa
